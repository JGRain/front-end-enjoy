import{_ as l,M as a,p as s,q as i,Q as h,R as e,t as o,N as t,a1 as n}from"./framework-5866ffd3.js";const c={},d=e("p",null,"最近依然在研究大型项目，而大型项目最容易遇到的问题便是性能问题。一般来说，当我们遇到性能瓶颈的时候，才会开始去进行相应的分析。分析的方向除了业务本身的特点相关之外，常见的我们还可以借助一些工具来发现问题。本文一起来研究下，前端性能分析可以怎么走~",-1),p=n('<h1 id="前端性能分析工具-chrome-devtools" tabindex="-1"><a class="header-anchor" href="#前端性能分析工具-chrome-devtools" aria-hidden="true">#</a> 前端性能分析工具（Chrome DevTools）</h1><p>一般来说，前端的性能分析通常可以从<strong>时间</strong>和<strong>空间</strong>两个角度来进行：</p><ul><li><strong>时间</strong>：常见耗时，如页面加载耗时、渲染耗时、网络耗时、脚本执行耗时等</li><li><strong>空间</strong>：资源占用，包括 CPU 占用、内存占用、本地缓存占用等</li></ul>',3),u={href:"https://developers.google.com/web/tools/chrome-devtools",target:"_blank",rel:"noopener noreferrer"},m=e("h2",{id:"lighthouse",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#lighthouse","aria-hidden":"true"},"#"),o(" Lighthouse")],-1),g={href:"https://github.com/GoogleChrome/lighthouse",target:"_blank",rel:"noopener noreferrer"},_=e("h3",{id:"架构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#架构","aria-hidden":"true"},"#"),o(" 架构")],-1),f=e("p",null,[e("img",{src:"https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/front-end-performance-analyze_7.png",alt:"Lighthouse 架构"})],-1),v=e("p",null,"下面是 Lighthouse 的组成部分：",-1),b={href:"https://chromedevtools.github.io/devtools-protocol/",target:"_blank",rel:"noopener noreferrer"},C=e("li",null,"收集器（Gatherers）：使用驱动程序收集页面的信息，收集器的输出结果被称为 Artifact",-1),D=e("li",null,"审查器（Audits）：将 Artifact 作为输入，审查器会对其运行测试，然后分配通过/失败/得分的结果",-1),P=e("li",null,"报告（Report）：将审查的结果分组到面向用户的报告中（如最佳实践），对该部分应用加权和总体然后得出评分",-1),T=n('<h3 id="主要功能" tabindex="-1"><a class="header-anchor" href="#主要功能" aria-hidden="true">#</a> 主要功能</h3><p>Lighthouse 会在一系列的测试下运行网页，比如不同尺寸的设备和不同的网络速度。它还会检查页面对辅助功能指南的一致性，例如颜色对比度和 ARIA 最佳实践。</p><p>在比较短的时间内，Lighthouse 可以给出这样一份报告（可将报告生成为 JSON 或 HTML）：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/front-end-performance-analyze_2.png" alt="Lighthouse 架构"></p><p>这份报告从 5 个方面来分析页面： <strong>性能</strong>、<strong>辅助功能</strong>、<strong>最佳实践</strong>、<strong>搜索引擎优化</strong>和 <strong>PWA</strong>。像性能方面，会给出一些常见的耗时统计。除此以外，还会给到一些详细的优化方向。</p><p>如果你希望短时间内对你的网站进行较全面的评估，可以使用 Lighthouse 来跑一下分数，确定大致的优化方向。</p><h2 id="performance-面板" tabindex="-1"><a class="header-anchor" href="#performance-面板" aria-hidden="true">#</a> Performance 面板</h2>',7),S={href:"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference",target:"_blank",rel:"noopener noreferrer"},k={href:"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},w=e("strong",null,"运行时性能",-1),x=e("h3",{id:"使用步骤",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#使用步骤","aria-hidden":"true"},"#"),o(" 使用步骤")],-1),y=e("p",null,"Performance 面板功能特别多，具体的分析也可以单独讲一篇了。这里我们简单说一下使用的步骤：",-1),L=e("li",null,"在隐身模式下打开 Chrome。隐身模式可确保 Chrome 以干净状态运行，例如浏览器的扩展可能会在性能评估中产生影响。",-1),J={href:"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance",target:"_blank",rel:"noopener noreferrer"},M=e("li",null,"按照提示单击记录，开始记录。进行完相应的操作之后，点击停止。",-1),N=e("li",null,"当页面运行时，DevTools 捕获性能指标。停止记录后，DevTools 处理数据，然后在 Performance 面板上显示结果。",-1),R=n('<h3 id="主要功能-1" tabindex="-1"><a class="header-anchor" href="#主要功能-1" aria-hidden="true">#</a> 主要功能</h3><p>关于 Performance 怎么使用的文章特别多，大家网上随便搜一下就能搜到。一般来说，主要使用以下功能：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/front-end-performance-analyze_5.jpg" alt=""></p><ul><li><strong>查看 FPS 图表</strong>：当在 FPS 上方看到红色条形时，表示帧速率下降得太低，以至于可能损害用户体验。通常，绿色条越高，FPS 越高</li><li><strong>查看 CPU 图表</strong>：CPU 图表在 FPS 图表下方。CPU 图表的颜色对应于性能板的底部的 Summary 选项卡</li><li><strong>查看 火焰图</strong>：火焰图直观地表示出了内部的 CPU 分析，横轴是时间，纵轴是调用指针，调用栈最顶端的函数在最下方。启用 JS 分析器后，火焰图会显示调用的每个 JavaScript 函数，可用于分析具体函数</li><li><strong>查看 Buttom-up</strong>：此视图可以看到某些函数对性能影响最大，并能够检查这些函数的调用路径</li></ul>',4),U={href:"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference",target:"_blank",rel:"noopener noreferrer"},z=n('<h3 id="performance-monitor" tabindex="-1"><a class="header-anchor" href="#performance-monitor" aria-hidden="true">#</a> Performance Monitor</h3><p>打开 Chrome 控制台后，按组合键<code>ctrl + p</code>(Mac 快捷键为<code>command + p</code>)，输入<code>&gt; Show Performance Monitor</code>，就可以打开 Performance Monitor 性能监视器。主要的监控指标包括：</p><ul><li>CPU usage：CPU 占用率</li><li>JS head size：JS 内存使用大小</li><li>DOM Nodes：内存中挂载的 DOM 节点个数</li><li>JS event listeners：事件监听数</li><li>...：其他等等</li></ul><p>大多数情况下，我们在进行性能优化的时候，使用上面一些工具也足以确定大致的优化方向。更多的细节和案例，就不在这里详述了。</p><h1 id="前端性能监控" tabindex="-1"><a class="header-anchor" href="#前端性能监控" aria-hidden="true">#</a> 前端性能监控</h1><p>除了具体的性能分析和定位，我们也经常需要对业务进行性能监控。前端性能监控包括两种方式：合成监控（Synthetic Monitoring，SYN）、真实用户监控（Real User Monitoring，RUM）。</p><h2 id="合成监控" tabindex="-1"><a class="header-anchor" href="#合成监控" aria-hidden="true">#</a> 合成监控</h2><p>合成监控就是在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。例如上面介绍的 Lighthouse 就是合成监控。</p><p>合成监控的使用场景不多，一般可能出现在开发和测试的过程中，例如结合流水线跑性能报告、定位性能问题时本地跑的一些简单任务分析等。该方式的优点显而易见：</p>',9),W={href:"https://chromedevtools.github.io/devtools-protocol/",target:"_blank",rel:"noopener noreferrer"},A=e("li",null,"较成熟的解决方案和工具，实现成本低",-1),O=e("li",null,"不影响真实用户的性能体验",-1),q=n('<h2 id="真实用户监控" tabindex="-1"><a class="header-anchor" href="#真实用户监控" aria-hidden="true">#</a> 真实用户监控</h2><p>真实用户监控，就是用户在我们的页面上访问，访问之后就会产生各种各样的性能指标。我们在用户访问结束的时候，把这些性能指标上传到我们的日志服务器上，进行数据的提取清洗加工，最后在我们的监控平台上进行展示的一个过程。</p><p>我们提及前端监控的时候，大多数都包括了真实用户监控。常见的一些性能监控包括加载耗时、DOM 渲染耗时、接口耗时统计等，而对于页面加载过程，可以看到它被定义成了很多个阶段：</p><p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/front-end-performance-analyze_6.png" alt="RUM 性能模型"></p><p>而我们要做的，则是在力所能及的地方进行打点、计算、采集、上报，该过程常常需要借助 Performance Timeline API。将需要的数据发送到服务端，然后再对这些数据进行处理，最终通过可视化等方式进行监控。因此，真实用户监控往往需要结合业务本身的前后端架构设计来建设，其优点也比较容易理解：</p><ul><li>完全还原真实场景，减去模拟成本</li><li>数据样本足够抹平个体的差异</li><li>采集数据可用于更多场景的分析和优化</li></ul><p>对比合成监控，真实用户监控在有些场景下无法拿到更多的性能分析数据（例如具体哪里 CPU 占用、内存占用高），因此更多情况下作为优化效果来参考。这些情况下，具体的分析和定位可能还是得依赖合成监控。</p><p>但真实用户监控也有自身的优势，例如 TCP、DNS 连接耗时过高，在各种环境下的一些运行耗时问题，合成监控是很难发现的。</p><h1 id="性能分析自动化" tabindex="-1"><a class="header-anchor" href="#性能分析自动化" aria-hidden="true">#</a> 性能分析自动化</h1><p>我们在开发过程中，也常常需要进行性能分析。而前端的性能分析上手成本也不低，除了基本的页面加载耗时、网络耗时，更具体的定位往往需要结合前面介绍的 Performance 面板、FPS、CPU、火焰图等一点点来分析。</p><p>如果这一块想要往自动化方向发展，我们可以怎么做呢？</p><h2 id="使用-lighthouse" tabindex="-1"><a class="header-anchor" href="#使用-lighthouse" aria-hidden="true">#</a> 使用 Lighthouse</h2><p>前面也有介绍 Lighthouse，它提供了脚本的方式使用。因此，我们可以通过自动化任务跑脚本的方式，使用 Lighthouse 跑分析报告，通过对比以往的数据来进行功能变更、性能优化等场景的性能回归。</p>',13),j={href:"https://github.com/GoogleChrome/lighthouse/blob/master/docs/configuration.md",target:"_blank",rel:"noopener noreferrer"},F=e("p",null,"不过由于 Lighthouse 同样基于 CDP(Chrome DevTools Protocol)，因此除了实现成本降低了，CDP 缺失的一些能力它也一样会缺失。",-1),H=e("h2",{id:"chrome-devtools-protocol",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#chrome-devtools-protocol","aria-hidden":"true"},"#"),o(" Chrome DevTools Protocol")],-1),V={href:"https://chromedevtools.github.io/devtools-protocol/",target:"_blank",rel:"noopener noreferrer"},E=n('<h3 id="认识-chrome-devtools-协议" tabindex="-1"><a class="header-anchor" href="#认识-chrome-devtools-协议" aria-hidden="true">#</a> 认识 Chrome DevTools 协议</h3><p>Chrome DevTools 协议基于 WebSocket，利用 WebSocket 建立连接 DevTools 和浏览器内核的快速数据通道。</p><p>我们使用的 Chrome DevTools 其实也是一个 Web 应用。我们使用 DevTools 的时候，浏览器内核 Chromium 本身会作为一个服务端，我们看到的浏览器调试工具界面，通过 Websocket 和 Chromium 进行通信。建立过程如下：</p><ol><li>DevTools 将作为 Web 应用程序，Chromium 作为服务端提供连接。</li><li>通过 HTTP 提取 HTML、JavaScript 和 CSS 文件。</li><li>资源加载后，DevTools 会建立与浏览器的 Websocket 连接，并开始交换 JSON 消息。</li></ol><p>同样的，当我们通过 DevTools 从 Windows、Mac 或 Linux 计算机远程调试 Android 设备上的实时内容时，使用的也是该协议。当 Chromium 以一个<code>--remote-debugging-port=0</code>标志启动时，它将启动 Chrome DevTools 协议服务器。</p><h3 id="chrome-devtools-协议域划分" tabindex="-1"><a class="header-anchor" href="#chrome-devtools-协议域划分" aria-hidden="true">#</a> Chrome DevTools 协议域划分</h3><p>Chrome DevTools协议具有与浏览器的许多不同部分（例如页面、Service Worker 和扩展程序）进行交互的 API。该协议把不同的操作划分为了不同的域（domain），每个域负责不同的功能模块。比如<code>DOM</code>、<code>Debugger</code>、<code>Network</code>、<code>Console</code>和<code>Performance</code>等，可以理解为 DevTools 中的不同功能模块。</p><p>使用该协议我们可以：</p>',8),I=e("li",null,[o("获取 JS 的 Runtime 数据，常用的如"),e("code",null,"window.performance"),o("和"),e("code",null,"window.chrome.loadTimes()"),o("等")],-1),B=e("li",null,[o("获取"),e("code",null,"Network"),o("及"),e("code",null,"Performance"),o("数据，进行自动性能分析")],-1),G={href:"https://github.com/GoogleChrome/lighthouse/blob/master/docs/puppeteer.md",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://pptr.dev/#?product=Puppeteer&version=v1.13.0&show=api-class-cdpsession",target:"_blank",rel:"noopener noreferrer"},Y=n('<h3 id="与性能相关的域" tabindex="-1"><a class="header-anchor" href="#与性能相关的域" aria-hidden="true">#</a> 与性能相关的域</h3><p>本文讲性能分析相关，因此这里我们只关注和性能相关的域。</p><p><strong>1. Performance。</strong> 从<code>Performance</code>域中<code>Performance.getMetrics()</code>可以拿到获取运行时性能指标包括：</p><ul><li><code>Timestamp</code>: 采取度量样本的时间戳</li><li><code>Documents</code>: 页面中的文档数</li><li><code>Frames</code>: 页面中的帧数</li><li><code>JSEventListeners</code>: 页面中的事件数</li><li><code>Nodes</code>: 页面中的 DOM 节点数</li><li><code>LayoutCount</code>: 全部或部分页面布局的总数</li><li><code>RecalcStyleCount</code>: 页面样式重新计算的总数</li><li><code>LayoutDuration</code>: 所有页面布局的合并持续时间</li><li><code>RecalcStyleDuration</code>: 所有页面样式重新计算的总持续时间</li><li><code>ScriptDuration</code>: JavaScript 执行的持续时间</li><li><code>TaskDuration</code>: 浏览器执行的所有任务的合并持续时间</li><li><code>JSHeapUsedSize</code>: 使用的 JavaScript 栈大小</li><li><code>JSHeapTotalSize</code>: JavaScript 栈总大小</li></ul><p><strong>2. Tracing。</strong><code>Tracing</code>域可获取页面加载的 DevTools 性能跟踪。可以使用<code>Tracing.start</code>和<code>Tracing.stop</code>创建可在 Chrome DevTools 或时间轴查看器中打开的跟踪文件。</p><p>我们能看到生成的 JSON 文件长这样： <img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/front-end-performance-analyze_8.png" alt=""></p>',6),K={href:"https://chromedevtools.github.io/timeline-viewer/",target:"_blank",rel:"noopener noreferrer"},X=n('<p><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/front-end-performance-analyze_9.jpg" alt=""></p><p><strong>3. Runtime。</strong><code>Runtime</code>域通过远程评估和镜像对象暴露 JavaScript 的运行时。可以通过<code>Runtime.getHeapUsage</code>获取 JavaScript 栈的使用情况，通过<code>Runtime.evaluate</code>计算全局对象的表达式，通过<code>Runtime.queryObjects</code>迭代 JavaScript 栈并查找具有给定原型的所有对象（可用于计算原型链中某处具有相同原型的所有对象，衡量 JavaScript 内存泄漏）。</p><p>除了上面介绍的这些，还有<code>Network</code>可以分析网络相关的性能，以及其他可能涉及 DOM 节点、JS 执行等各种各样的数据分析，更多的可能需要大家自己去研究了。</p><h3 id="自动化性能分析" tabindex="-1"><a class="header-anchor" href="#自动化性能分析" aria-hidden="true">#</a> 自动化性能分析</h3><p>通过使用 Chrome DevTools 协议，我们可以获取 DevTools 提供的很多数据，包括网络数据、性能数据、运行时数据。</p>',5),Z={href:"https://github.com/ChromeDevTools/awesome-chrome-devtools#chrome-devtools-protocol",target:"_blank",rel:"noopener noreferrer"},$=e("p",null,"至于我们到底能拿到怎样的数据，可以做到怎样的自动化程度，就不在本文里讲述啦，后面有机会再开篇文章详细讲讲。",-1),ee=e("h1",{id:"参考",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考","aria-hidden":"true"},"#"),o(" 参考")],-1),oe={href:"https://www.zcfy.cc/article/the-new-chrome-devtool-feature-you-want-to-know-about-3318.html",target:"_blank",rel:"noopener noreferrer"},re={href:"https://juejin.im/post/6844904045774110733",target:"_blank",rel:"noopener noreferrer"},te={href:"https://www.infoq.cn/article/Dxa8aM44oz*Lukk5Ufhy",target:"_blank",rel:"noopener noreferrer"},ne={href:"https://testerhome.com/topics/15817",target:"_blank",rel:"noopener noreferrer"},le={href:"https://chromedevtools.github.io/devtools-protocol/",target:"_blank",rel:"noopener noreferrer"},ae={href:"https://addyosmani.com/blog/puppeteer-recipes/#measuring-memory-leaks",target:"_blank",rel:"noopener noreferrer"},se=e("h1",{id:"结束语",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#结束语","aria-hidden":"true"},"#"),o(" 结束语")],-1),ie=e("p",null,"前端性能分析相关的文章不算多，而由于性能分析本身的场景就跟业务特性结合比较紧密，可以用来借鉴的内容、较统一的解决方案也不多。而性能的监控、自动化等方向的介绍比较少，也希望这篇文章能给到你们一些方向吧~",-1);function he(ce,de){const r=a("ExternalLinkIcon");return s(),i("div",null,[d,h("more"),p,e("p",null,[o("那么，下面来看看有哪些常见的工具可以借来用用。由于我们的网页基本上跑在浏览器中，所以基本上大多数的工具都来源于浏览器自身提供，首当其冲的当然是 "),e("a",u,[o("Chrome DevTools"),t(r)]),o("。本文我们也主要围绕 Chrome DevTools 来进行说明。")]),m,e("p",null,[e("a",g,[o("Lighthouse"),t(r)]),o(" 的前身是 Chrome DevTools 面板中的 Audits。在 Chrome 60 之前的版本中, 这个面板只包含网络使用率和页面性能两个测量类别，从 Chrome 60 版本开始， Audits 面板已经被 Lighthouse 的集成版取代。而在最新版本的 Chrome 中，则需要单独安装 Lighthouse 拓展程序来使用，也可以通过脚本来使用。")]),_,f,v,e("ul",null,[e("li",null,[o("驱动（Driver）：和 "),e("a",b,[o("Chrome Debugging Protocol"),t(r)]),o(" 进行交互的接口")]),C,D,P]),T,e("p",null,[e("a",S,[o("Performance"),t(r)]),o(" 面板同样有个前身，叫 "),e("a",k,[o("Timeline"),t(r)]),o("。该面板用于记录和分析"),w,o("，运行时性能是页面运行时（而不是加载）的性能。")]),x,y,e("ol",null,[L,e("li",null,[o("在 DevTools 中，单击“Performance”选项卡，并进行一些基础配置（更多参考"),e("a",J,[o("官方说明"),t(r)]),o("）。")]),M,N]),R,e("p",null,[o("具体要怎么定位某些性能瓶颈，可以参考"),e("a",U,[o("官方文档系列文章"),t(r)]),o("，这里就不详细介绍啦。")]),z,e("ul",null,[e("li",null,[o("可采集更丰富的数据指标，例如结合 "),e("a",W,[o("Chrome Debugging Protocol"),t(r)]),o(" 获取到的数据")]),A,O]),q,e("p",null,[o("使用 Lighthouse 的优势在于开发成本低，只需要按照"),e("a",j,[o("官方提供的配置"),t(r)]),o("来调整、获取自己需要的一些数据，就可以快速接入较全面的 Lighthouse 拥有的性能分析能力。")]),F,H,e("p",null,[e("a",V,[o("Chrome DevTools Protocol"),t(r)]),o(" 允许第三方对基于 Chrome 的 Web 应用程序进行检测、检查、调试、分析等。有了这个协议，我们就可以自己开发工具获取 Chrome 的数据了。")]),E,e("ul",null,[I,B,e("li",null,[o("使用 "),e("a",G,[o("Puppeteer"),t(r)]),o(" 的 "),e("a",Q,[o("CDPSession"),t(r)]),o("，与浏览器的协议通信会变得更加简单")])]),Y,e("p",null,[o("这样的 JSON 文件，我们可以丢到 "),e("a",K,[o("DevTools Timeline Viewer"),t(r)]),o(" 中，可以看到对应的时间轴和火焰图：")]),X,e("p",null,[o("对于如何使用该协议，其实已经有很多大神针对这个协议封装出不同语言的库，包括 Node.js、Python、Java等，可以根据需要在 "),e("a",Z,[o("awesome-chrome-devtools"),t(r)]),o(" 这个项目中找到。")]),$,ee,e("ul",null,[e("li",null,[e("a",oe,[o("你一定要知道的 Chrome DevTool 新功能"),t(r)])]),e("li",null,[e("a",re,[o("前端性能分析利器-Chrome性能分析&性能监视器"),t(r)])]),e("li",null,[e("a",te,[o("蚂蚁金服如何把前端性能监控做到极致?"),t(r)])]),e("li",null,[e("a",ne,[o("chrome devtools protocol——Web 性能自动化实践介绍"),t(r)])]),e("li",null,[e("a",le,[o("Chrome DevTools Protocol"),t(r)])]),e("li",null,[e("a",ae,[o("Web Performance Recipes With Puppeteer"),t(r)])])]),se,ie])}const ue=l(c,[["render",he],["__file","front-end-performance-analyze.html.vue"]]);export{ue as default};
